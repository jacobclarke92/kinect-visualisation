#!/usr/bin/env node

var BufferedNetstringStream = require('./app/libs/netstring').BufferedNetstringStream;
var http = require('http');
var fs = require('fs');
var url = require("url");
var midi = require('web-midi-api');
var httpRequest = require('http-request');
var chokidar = require('chokidar');
var less = require('less');

var clients = [];

var selectPort = 0;

var quickStart = false;
var skipColour = false;
var skipMidi = false;
var skipEffectsList = false;
var devMode = false;



var log = console.log.bind(console);

console.reset = function () { return process.stdout.write('\033c') }
//console.reset();

if(process.argv.length > 2) {
	var params = process.argv.slice(2);

	for(var i=0; i < params.length; i++) {
		
		var param = params[i];
		if(param.indexOf('-port') === 0) selectPort = parseInt( param.substring(5,param.length) );
		else if(param.indexOf('-quick') === 0) quickStart = true;
		else if(param.indexOf('-skipmidi') === 0) skipMidi = true;
		else if(param.indexOf('-skipcolour') === 0) skipColour = true;
		else if(param.indexOf('-skipeffectslist') === 0) skipMidi = true;
		else if(param.indexOf('-devmode') === 0) devMode = true;
	}
}else{
	console.log("no params given! include -portXX to select midi device");
}


function compileLess(path) {
	var fpath = path.replace(/\\/g, '/');
	var fname = fpath.substring(fpath.lastIndexOf('/')+1, fpath.lastIndexOf('.'));
	fpath = 'app/styles/generated/'+fname+'.css';
	fs.readFile(path,function(error,data){
	    data = data.toString();
	    // console.log(data);
	    less.render(data, function (e, css) {
	        fs.writeFile(fpath, css.css, function(err){
	            console.log('css compiled for ',path,' at ',fpath);
	        });
	    });
	});
}

compileLess('./app/styles/ui.less');
compileLess('./app/styles/core.less');
if(devMode) {
	var watcher = chokidar.watch('file', {
	  ignored: /[\/\\]\./, persistent: true
	});
	watcher.on('change', function(path, stats) {

		compileLess(path);

	});
	watcher.add('./app/styles/*.less');

}

if(!skipEffectsList) {

	var effects = [];
	var effectsScanned = 0;
	fs.readdir('./effects/',function(err, files) {
		if(!err) {

			if(files.length > 0) {
				var totalEffects = files.length;

				console.log('Scanning effects folder...');
				files.forEach(function(file) {
					if(file.indexOf('effect_') === 0) {
						fs.readFile('./effects/'+file, 'utf8', function(err,data) {
							if(err) console.log('Error reading ',file);
							else if(data.indexOf('//exclude') != 0) effects.push(file.substring(7,file.length-3));
							else console.log('Exluding ',file);

							if(++effectsScanned >= totalEffects) {

								console.log(effects.length+' effects scanned');
								var str = 'effects = ["'+effects.join('", "')+'"];';
								fs.writeFile('./app/scripts/effects_list.js', str, function() {
									if(err) console.log('Unable to save effects list!');
								});
							}

						});
					}else totalEffects--;
				});
				
				// fs.writeFile()

			}else{
				console.log('No effect files in effects folder ... um send help.')
			}
		}else{
			console.log('Error scanning effects folder... very problematic!')
		}
	});

}




var midi;
var inputs;
var outputs;

if(!skipMidi) {

	function onsuccesscallback( access ) {
		midi = access;
		inputs = midi.inputs;
		outputs = midi.outputs;
		var portCount = inputs.size;
		console.log(portCount+" MIDI PORTS AVAILABLE");
		if(portCount != 0) {
			if(portCount < selectPort) {
				console.log("UNABLE TO USE PORT "+selectPort+". Reverting to 0");
				selectPort = 0;
			}

			var devices = inputs.values();
			// console.log(devices);
			for(var i=0; i < devices._items.length; i++) {
				console.log('port'+i+': '+devices._items[i].name);
			}
			console.log("Using port "+selectPort);
			devices._items[selectPort].onmidimessage = onMidiIn;

		}
	}
	function onerrorcallback( err ) {
		console.log( "uh-oh midi-o! Something went wrong! Error code: " + err.code );
	}
	function onMidiIn(ev){
		var arr = [];
		for(var i=0; i<ev.data.length; i++) arr.push(ev.data[i]);//arr.push((ev.data[i]<16 ? '0' : '') + ev.data[i].toString(16));
		clients.forEach(function(client) {
			client.write('data: ' + arr.join(' ') + '\n\n');
		});
		console.log('MIDI:', arr.join(' '));
	}

	midi.requestMIDIAccess().then( onsuccesscallback, onerrorcallback );

}else{
	console.log('Skipping midi setup');
}

//get top colours xml

if(!skipColour) {
	console.log('Attempting to download top colour palettes...')
	httpRequest.get('http://www.colourlovers.com/api/palettes/top?numResults=24', './app/palettes.xml', function (error, result) {
			if (error) {
					console.error('Error getting xml file',error);
			} else {
					console.log('File downloaded at: ' + result.file);
			}
	});
}else{
	console.log('Skipping colour palette download');
}



//start doing stream data stuff
var id = 0;

function stream(req, res) {
	res.writeHead(200, {
		'Content-Type':  'text/event-stream',
		'Cache-Control': 'no-cache',
		'Connection':    'keep-alive'
	});

	clients.push(res);

	req.on('close', function() {
		var index = clients.indexOf(res);
		if (index != -1) {
			clients.splice(index, 1);
		}
	});
}


function serve(res, path, contentType) {
	fs.readFile(path, function(err, data) {
		if (err) {
			res.writeHead(500, {'Content-Type': 'text/plain'});
			res.write('500 Error');
		} else {
			res.writeHead(200, {'Content-Type': contentType});
			res.write(data);
		}
		res.end();
	});
}

function writeImage(image) {

	console.log(image);
	var uri = 'data:image/png;base64,' + image.toString('base64');

	clients.forEach(function(client) {
		client.write('id: ' + id + '\n');
		//client.write('fft: ' + JSON.stringify(fftLevels) + '\n');
		client.write('data: ' + uri + '\n\n');  

		//fftLevels = new Array(2048);
	});

	id++;
}

var urlRules = [

	['/effects/','application/javascript'],
	['.pde','text/processing'],
	['.png','image/png'],
	['.js','application/javascript'],
	['.html','text/html'],
	['.css','text/css'],
	['.json','text/event-stream'],
	['.xml','text/xml'],

	['.svg','image/svg+xml'],
	['.ttf','application/x-font-ttf'],
	['.otf','application/x-font-opentype'],
	['.woff','application/x-font-woff'],
	['.eot','application/vnd.ms-fontobject']
];

var server = http.createServer(function(req, res) {

	var parsedURL = url.parse(req.url, true);
	var pathname = parsedURL.pathname;
	// console.log(pathname);
	
	if (req.url == '/images' || pathname == '/app/midi.json') {
		
		stream(req, res, 'text/event-stream');

	} else {
		var found = false;
		for(var i=0; i< urlRules.length; i++) {
			if (req.url.indexOf(urlRules[i][0]) > -1) {
				serve(res, __dirname + req.url, urlRules[i][1]);
				found = true;
			}
		}
		if(!found) {
			if(pathname == '/') serve(res, __dirname + '/app/index.html', 'text/html');
			else res.end();
		}
	}

});
function startServer() {
	process.stdin.resume();
	process.stdin.pipe(new BufferedNetstringStream).on('data', writeImage);
	server.listen(5600);

	console.log('Node server started!'); 
}

if(quickStart) startServer();
else{
	var interval = false;
	var count = 5;
	setTimeout(function() {
		console.log('5 seconds until node server launch...');
		setTimeout(function() {

			startServer();
			
			clearInterval(interval);
		},5000);
		interval = setInterval(function() {
			count --;
			console.log(count);
		},1000);
	},1500);
}
