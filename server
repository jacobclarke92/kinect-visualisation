#!/usr/bin/env node

//util modules
// var BufferedNetstringStream = require('./app/libs/netstring').BufferedNetstringStream;
var app = require('http');
var fs = require('fs');
var httpRequest = require('http-request');
var url = require("url");
var BufferStream = require('bufferstream');
var WebSocketServer = require('ws').Server;
var websocket = require('websocket-stream');

var sys = require('sys')
var exec = require('child_process').exec;
var child;

//app specific modules
var midi = require('midi');
var keypress = require('keypress');
var kinect = require('kinect');

//compilation modules
var chokidar = require('chokidar');
var less = require('less');

var clients = [];

var selectPort = 0;

var quickStart = false;
var skipColour = false;
var skipMidi = false;
var skipKinect = false;
var skipEffectsList = false;
var devMode = false;


app.globalAgent.maxSockets = 500;

var log = console.log.bind(console);

console.reset = function () { return process.stdout.write('\033c') }
//console.reset();

if(process.argv.length > 2) {
	var params = process.argv.slice(2);

	for(var i=0; i < params.length; i++) {
		
		var param = params[i];
		if(param.indexOf('-port') === 0) selectPort = parseInt( param.substring(5,param.length) );
		else if(param.indexOf('-quick') === 0) quickStart = true;
		else if(param.indexOf('-skipmidi') === 0) skipMidi = true;
		else if(param.indexOf('-skipcolour') === 0) skipColour = true;
		else if(param.indexOf('-skipeffectslist') === 0) skipMidi = true;
		else if(param.indexOf('-skipkinect') === 0) skipKinect = true;
		else if(param.indexOf('-devmode') === 0) devMode = true;
	}
}else{
	console.log("no params given! include -portXX to select midi device");
}


function compileLess(path) {
	var fpath = path.replace(/\\/g, '/');
	var fname = fpath.substring(fpath.lastIndexOf('/')+1, fpath.lastIndexOf('.'));
	fpath = 'app/styles/generated/'+fname+'.css';
	fs.readFile(path,function(error,data) {
	    data = data.toString();
	    // console.log(data);
	    less.render(data, function (e, css) {
	        fs.writeFile(fpath, css.css, function(err){
	            console.log('css compiled for ',path,' at ',fpath);
	        });
	    });
	});
}

function compileScript() {
	console.log('Browserifying connections.js');
	child = exec("browserify ./app/scripts/core/connections.js -o ./app/scripts/core/connections_built.js", function (error, stdout, stderr) {
		sys.print('stdout: ' + stdout);
		sys.print('stderr: ' + stderr);
		if (error !== null) {
			console.log('exec error: ' + error);
		}
	});
}

compileLess('./app/styles/ui.less');
compileLess('./app/styles/core.less');
compileScript();
if(devMode) {

	var lessWatcher = chokidar.watch('file', {
	  ignored: /[\/\\]\./, persistent: true
	});
	lessWatcher.on('change', function(path, stats) {
		compileLess(path);
	});
	lessWatcher.add('./app/styles/*.less');

	var scriptWatcher = chokidar.watch('file', {persistent: true});
	scriptWatcher.on('change', function(path, stats) {
		compileScript();
	});
	scriptWatcher.add('./app/scripts/core/connections.js');

}

if(!skipEffectsList) {

	var effects = [];
	var effectsScanned = 0;
	fs.readdir('./effects/',function(err, files) {
		if(!err) {

			if(files.length > 0) {
				var totalEffects = files.length;

				console.log('Scanning effects folder...');
				files.forEach(function(file) {
					if(file.indexOf('effect_') === 0) {
						fs.readFile('./effects/'+file, 'utf8', function(err,data) {
							if(err) console.log('Error reading ',file);
							else if(data.indexOf('//exclude') != 0) effects.push(file.substring(7,file.length-3));
							else console.log('Exluding ',file);

							if(++effectsScanned >= totalEffects) {

								console.log(effects.length+' effects scanned');
								var str = 'effects = ["'+effects.join('", "')+'"];';
								fs.writeFile('./app/scripts/effects_list.js', str, function() {
									if(err) console.log('Unable to save effects list!');
								});
							}

						});
					}else totalEffects--;
				});
				
				// fs.writeFile()

			}else{
				console.log('No effect files in effects folder ... um send help.')
			}
		}else{
			console.log('Error scanning effects folder... very problematic!')
		}
	});

}




var midi;
var inputs;
var outputs;

if(!skipMidi) {

	var input = new midi.input();
	var ports = input.getPortCount();
	if(ports < selectPort) {
		console.log("UNABLE TO USE PORT "+selectPort+". Reverting to 0");
		selectPort = 0;
	}
	console.log(ports+" MIDI PORTS AVAILABLE");
	for(var i=0; i<ports; i++) {
		console.log('port'+i+': '+input.getPortName(i));
	}

	input.on('message', function(deltaTime, message) {
		console.log('m:' + message + ' d:' + deltaTime);
		clients.forEach(function(client) {
			client.write('data: ' + message.join(' ') + '\n\n');
		});
	});

	input.openPort(selectPort);

}else{
	console.log('Skipping midi setup');
}

//get top colours xml

if(!skipColour) {
	console.log('Attempting to download top colour palettes...')
	httpRequest.get('http://www.colourlovers.com/api/palettes/top?numResults=24', './app/palettes.xml', function (error, result) {
			if (error) {
					console.error('Error getting xml file',error);
			} else {
					console.log('File downloaded at: ' + result.file);
			}
	});
}else{
	console.log('Skipping colour palette download');
}





var urlRules = [
	['.pde','text/processing'],
	['.png','image/png'],
	['.js','application/javascript'],
	['.html','text/html'],
	['.css','text/css'],
	['.json','text/event-stream'],
	['.xml','text/xml'],

	['.svg','image/svg+xml'],
	['.ttf','application/x-font-ttf'],
	['.otf','application/x-font-opentype'],
	['.woff','application/x-font-woff'],
	['.eot','application/vnd.ms-fontobject']
];


//start doing stream data stuff
var id = 0;

function stream(req, res) {
	res.writeHead(200, {
		'Content-Type':  'text/event-stream',
		'Cache-Control': 'no-cache',
		'Connection':    'keep-alive'
	});

	clients.push(res);

	req.on('close', function() {
		var index = clients.indexOf(res);
		if (index != -1) {
			clients.splice(index, 1);
		}

	});
}

var appServer = app.createServer(function(req, res) {

	var parsedURL = url.parse(req.url, true);
	var pathname = parsedURL.pathname;
	// console.log(pathname);

	var reqURL = __dirname + req.url;
	if(pathname == '/') reqURL = __dirname + '/app/index.html';
	
	if (pathname == '/app/midi.json') {
		
		stream(req, res, 'text/event-stream');
		console.log('midi stream requested');

	} else {
		var mimeType = false;
		for(var i=0; i< urlRules.length; i++) {
			if (reqURL.indexOf(urlRules[i][0]) > -1) {
				mimeType = urlRules[i][1];
				i = urlRules.length;
			}
		}
		if(!mimeType) mimeType = 'text/plain';
		fs.readFile(reqURL, function (err, data) {
			if (err) {
				res.writeHead(500);
				return res.end('Error loading ' +reqURL);
				console.log('Error loading ' +reqURL);
			}
			res.writeHead(200,{
				'Content-Type': mimeType
			});
			res.end(data);
		});
		/*
		
		*/
	}

});


// ~~			   ~~ //
// ~~ kinect stuff ~~ //
// ~~ 			   ~~ //

//init camera controls

var wss;
var kstream;
var kcontext;

if(!skipKinect) {

	console.log('Initialising kinect!');

	kstream = new BufferStream();

	wss = new WebSocketServer({server: appServer});

	//init socket stream
	wss.on('connection', function(ws) {
		var stream = websocket(ws);
		kstream.pipe(stream);
		console.log("connection made");
		ws.on('close', function() {
			stream.writable = false;
			console.log('closed socket');
		});

	});

	kcontext = kinect();
	
	//init kinect depth data stream
	kcontext.resume();
	kcontext.start('depth');

	kcontext.on('depth', function (buf) {
	  kstream.write(buf);
	});

	//init terminal kinect controls
	var kinectAngle = 0;
	updateKinectAngle(0);

	keypress(process.stdin);
	process.stdin.on('keypress', function (ch, key) {

	  if(key.name == 'up') updateKinectAngle(1);
	  else if(key.name == 'down') updateKinectAngle(-1);

	  if (key && key.ctrl && key.name == 'c') process.exit(0);//process.stdin.pause(); // die gracefully
	});
	process.stdin.setRawMode(true);
	process.stdin.resume();


}

function updateKinectAngle(amt) {
  if(kinectAngle+amt <= 15 && kinectAngle+amt >= -15) {
    kinectAngle += amt;
    for(var i = -15, str=''; i < 15; i ++) str += (i == kinectAngle) ? '|' : '-';
    console.log('adjusting tilt: '+str);
    // console.log(kcontext);
    kcontext.tilt(kinectAngle);
  }
}




function startServer() {
	process.stdin.resume();
	appServer.listen(5600);

	console.log('Node server started!'); 
}




if(quickStart) startServer();
else{
	var interval = false;
	var count = 5;
	setTimeout(function() {
		console.log('5 seconds until node server launch...');
		setTimeout(function() {

			startServer();
			
			clearInterval(interval);
		},5000);
		interval = setInterval(function() {
			count --;
			console.log(count);
		},1000);
	},1500);
}
