#!/usr/bin/env node

var BufferedNetstringStream = require('./scripts/netstring').BufferedNetstringStream;
var http = require('http');
var fs = require('fs');
var url = require("url");
var midi = require('web-midi-api');
var httpRequest = require('http-request');

var clients = [];

var selectPort = 0;


console.reset = function () { return process.stdout.write('\033c') }
console.reset();

if(process.argv.length > 2) {
  var params = process.argv.slice(2);

  for(var i=0; i < params.length; i++) {
    
    var param = params[i];
    if(param.indexOf('-port') === 0) {
      selectPort = parseInt( param.substring(5,param.length) );
    }
  }
}else{
  console.log("no params given! include -portXX to select midi device");
}

var midi;
var inputs;
var outputs;


function onsuccesscallback( access ) {
  midi = access;
  inputs = midi.inputs;
  outputs = midi.outputs;
  var portCount = inputs.size;
  console.log(portCount+" MIDI PORTS AVAILABLE");
  if(portCount != 0) {
    if(portCount < selectPort) {
      console.log("UNABLE TO USE PORT "+selectPort+". Reverting to 0");
      selectPort = 0;
    }

    var devices = inputs.values();
    // console.log(devices);
    for(var i=0; i < devices._items.length; i++) {
      console.log('port'+i+': '+devices._items[i].name);
    }
    console.log("Using port "+selectPort);
    devices._items[selectPort].onmidimessage = onMidiIn;

  }
}
function onerrorcallback( err ) {
  console.log( "uh-oh midi-o! Something went wrong! Error code: " + err.code );
}
function onMidiIn(ev){
  var arr = [];
  for(var i=0; i<ev.data.length; i++) arr.push(ev.data[i]);//arr.push((ev.data[i]<16 ? '0' : '') + ev.data[i].toString(16));
  clients.forEach(function(client) {
    client.write('data: ' + arr.join(' ') + '\n\n');
  });
  console.log('MIDI:', arr.join(' '));
}

midi.requestMIDIAccess().then( onsuccesscallback, onerrorcallback );

//get top colours xml

console.log('Attempting to download top colour palettes...')
httpRequest.get('http://www.colourlovers.com/api/palettes/top?numResults=24', './palettes.xml', function (error, result) {
    if (error) {
        console.error('Error getting xml file',error);
    } else {
        console.log('File downloaded at: ' + result.file);
    }
});



//start doing stream data stuff
var id = 0;

function stream(req, res) {
  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });

  clients.push(res);

  req.on('close', function() {
    var index = clients.indexOf(res);
    if (index != -1) {
      clients.splice(index, 1);
    }
  });
}


function serve(res, path, contentType) {
  fs.readFile(path, function(err, data) {
    if (err) {
      res.writeHead(500, {'Content-Type': 'text/plain'});
      res.write('500 Error');
    } else {
      res.writeHead(200, {'Content-Type': contentType});
      res.write(data);
    }
    res.end();
  });
}

function writeImage(image) {

  console.log(image);
  var uri = 'data:image/png;base64,' + image.toString('base64');

  clients.forEach(function(client) {
    client.write('id: ' + id + '\n');
    //client.write('fft: ' + JSON.stringify(fftLevels) + '\n');
    client.write('data: ' + uri + '\n\n');  

    //fftLevels = new Array(2048);
  });

  id++;
}

var urlRules = [

  ['/effects/','application/javascript'],
  ['.pde','text/processing'],
  ['.png','image/png'],
  ['.js','application/javascript'],
  ['.html','text/html'],
  ['.css','text/css'],
  ['.json','text/event-stream'],
  ['.xml','text/xml']
];

var server = http.createServer(function(req, res) {

  var parsedURL = url.parse(req.url, true);
  var pathname = parsedURL.pathname;
  // console.log(pathname);
  
  if (req.url == '/images' || pathname == '/midi.json') {

    stream(req, res);

  } else {
    var found = false;
    for(var i=0; i< urlRules.length; i++) {
      if (req.url.indexOf(urlRules[i][0]) > -1) {
        serve(res, __dirname + req.url, urlRules[i][1]);
        found = true;
      }
    }
    if(pathname == '/') {
      serve(res, __dirname + '/index.html', 'text/html');
    }
  }

});

var interval = false;
var count = 5;
setTimeout(function() {
  console.log('5 seconds until node server launch...');
  setTimeout(function() {

    process.stdin.resume();
    process.stdin.pipe(new BufferedNetstringStream).on('data', writeImage);
    server.listen(5600);

    console.log('Node server started!');
    clearInterval(interval);
  },5000);
  interval = setInterval(function() {
    count --;
    console.log(count);
  },1000);
},1500);
